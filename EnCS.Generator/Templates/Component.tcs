using System.Runtime.Intrinsics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using EnCS;
using UtilLib.Memory;

namespace $namespace
{
	public ref partial struct $compName
	{
		public $compName()
		{
			throw new NotImplementedException("|$compName| should be created with Comp struct, not directly.");
		}

		public $compName($members~>ref $type $name<~~>, <~)
		{
			$members~>this.$name = ref $name;<~~>\n			<~
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Set(Comp c)
		{
			$members~>this.$name = c.|$name|;<~~>\n			<~
		}

		public ref struct Vectorized
		{
			$members|$arraySize < 2|~>public ref Vector|$bits|<$type> $name;<~|$arraySize > 1|~>public ref FixedBuffer|$arraySize|<Vector|$bits|<$type>> $name;<~~>\n			<~\n
		}

		public struct Comp
		{
			$members~>public $type $name;<~~>\n			<~

			public Comp($members~>$type $name<~~>, <~)
			{
				$members~>this.$name = $name;<~~>\n				<~
			}
		}

		public struct Memory
		{
			$members~>public Memory<$type> $name;<~~>\n			<~

			public Memory(int length)
			{
				$members~>this.$name = new $type[length];<~~>\n				<~
			}

			public |$compName|.Vectorized GetVec(int idx)
			{
				idx /= 8;
				idx *= 8;

				return new |$compName|.Vectorized
				{
					$members|$arraySize < 2|~> |$name| = ref Unsafe.As<$type, Vector|$bits|<$type>>(ref this.|$name|.Span[idx]),<~|$arraySize > 1|~> |$name| = ref Unsafe.As<$type, FixedBuffer|$arraySize|<Vector|$bits|<$type>>>(ref this.|$name|.Span.Slice[idx]),<~~>\n					<~///
				};
			}

			public |$compName| GetSingle(int idx)
			{
				return new |$compName|
				(
					$members~>ref this.|$name|.Span[idx]<~~>, \n					<~
				);
			}
		}
	}
}